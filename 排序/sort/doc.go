package sort

// 冒泡、选择、插入、归并、快速、希尔、堆排序，都是基于比较的排序 平均时间复杂度目前最低是 O(nlogn)
// 计数排序、桶排序、基数排序，都不是基于比较的排序 它们是典型的用空间换时间，在某些时候，平均时间复杂度可以比 O nlogn 更低
/*
排序算法的稳定性(Stability)
	如果相等的2个元素,在排序前后的相对位置保持不变,那么这是稳定的排序算法
		排序前:		5, 1, 3𝑎, 4, 7, 3𝑏
		稳定的排序: 	1, 3𝑎, 3𝑏, 4, 5, 7
		不稳定的排序:	1, 3𝑏, 3𝑎, 4, 5, 7
	对自定义对象进行排序时,稳定性会影响最终的排序效果
	冒泡排序属于稳定的排序算法 稍有不慎,稳定的排序算法也能被写成不稳定的排序算法,比如下面的冒泡排序代码是不稳定的
		if s.cmp(begin, begin-1) <= 0 { 不稳定的
			s.swap(begin, begin-1)
		}

原地算法(In-place Algorithm)
	不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入
	空间复杂度为 𝑂(1) 的都可以认为是原地算法
	非原地算法，称为 Not-in-place 或者 Out-of-place
*/

/**
什么是逆序对?
数组 <2,3,8,6,1> 的逆序对为:<2,1> <3,1> <8,1> <8,6> <6,1>，共5个逆序对
*/

/**
常见的递推式
		递推式						复杂度
	T(n) =T(n/2) + O(1)				O(logN)
	T(n) =T(n-1) + O(1)				O(n)
	T(n) =T(n/2) + O(n)				O(n)
	T(n) =2*T(n/2) + O(1)			O(n)
	T(n) =2*T(n/2) + O(n)			O(nlogN)
	T(n) =T(n-1) + O(n)				O(n^2)
	T(n) =2*T(n-1) + O(1)			O(2^n)
	T(n) =2*T(n-1) + O(n)			O(2^n)
*/
